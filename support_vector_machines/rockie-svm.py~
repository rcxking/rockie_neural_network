#!/usr/bin/python

'''
rockie-svm.py - This script creates and trains a support vector machine
to recognize the precached sample for Phase 1.   

RPI Rock Raiders
5/6/15

Last Updated: Bryant Pong: 5/6/15 - 7:27 PM
'''

# Python Imports
import cv2
import numpy as np
import matplotlib.pyplot as plt
import sklearn.svm as svm
import cPickle as pickle
import os

# Globals:
dataFolder = "../data/pickle/"
imgNames = ["sample_"]

'''
This function performs a sliding window technique to divide each image into 
regions to examine.
'''
def slidingWindow(img, winLen, winHgt): 

	# Size of the image:
	imgLen = img.shape[1]
	imgHgt = img.shape[0]

	# Ensure that this image can be evenly divided by winLen, winHgt:
	if winLen == 0 or winHgt == 0 or imgLen % winLen != 0 or imgHgt % winHgt != 0:
		print("Error window parameters do not divide img evenly!")
		return []	
											
	# Determine the number of window blocks to cover:
	numBlkLen = int(imgLen / winLen)
	numBlkHgt = int(imgHgt / winHgt)

	print("You can create: " + str(numBlkLen) + " blocks horizontally x " + \
	str(numBlkHgt) + " blocks vertically")
																	
	imgs = []
	# Extract the blocks:
	for m in xrange(numBlkHgt):
		for n in xrange(numBlkLen):
			nextCornerRow = m*winHgt
			nextCornerCol = n*winLen

			print("next corner at (" + str(nextCornerCol) + "," + str(nextCornerRow) + ")")
			imgs.append(img[nextCornerRow:nextCornerRow+winHgt, nextCornerCol:nextCornerCol+winLen])

	return imgs

'''
This function loads the training images and labels. 
'''
def loadData():
	for i in xrange(len(imgNames)):
		with open(dataFolder+imgNames[i]+".dat", "rb") as X:
			for dataTuple in pickle.load(X):
				#plt.imshow(dataTuple[0])
				#plt.show()			 

					

	return [], []

'''
This function creates a histogram-based image descriptor for the SVM to train
on.  The descriptor is a 8 x 8 x 8 color-based histogram.   
'''
def calcDescriptor(img):
	flattenedImg = img.flatten()

	numElements = 0
	nextPixel = []
	nextPos = 0

	convertedImg = np.zeros((360*240, 3))

	for val in np.diter(flattenedImg):
		numElements += 1
		nextPixel.append(val)

		if numElements >= 3:
			convertedImg[nextPos] = nextPixel
			nextPos += 1

			numElements = 0
			nextPixel = []

	histogram, _ = np.histogramdd(convertedImg, bins=[dim, dim, dim])

	return histogram.flatten()

# Main function.  Select either "train" or "predict"   
def main(action):

	if action == "train":
		# Train the support vector machine
		print("Now training support vector machine")	

		# Load the training images and labels:  
		print("Now loading training images and labels")
		X, y = loadData() 

if __name__ == "__main__":
	main("train")
